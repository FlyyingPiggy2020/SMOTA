# smOTA 升级协议规范

> **文档版本**: v1.0
> **编写日期**: 2026-01-26
> **协议版本**: 0x01

---

## 目录

0. [协议概述](#0-协议概述)
1. [固件包格式](#1-固件包格式)
2. [通信数据包格式](#2-通信数据包格式)
3. [升级流程](#3-升级流程)
4. [安全机制](#4-安全机制)
5. [超时与重传](#5-超时与重传)
6. [错误处理](#6-错误处理)
7. [附录](#7-附录)

---

## 0. 协议概述

本协议定义了 smOTA 固件升级的完整通信规范，包括：
- 固件包格式
- 通信数据包格式
- 升级流程
- 安全机制

### 0.1 协议层次

```
┌─────────────────────────────────────────┐
│         应用层协议 (smOTA Protocol)      │
├─────────────────────────────────────────┤
│         传输层 (UART / CAN / BLE / ...)  │
├─────────────────────────────────────────┤
│         物理层                           │
└─────────────────────────────────────────┘
```

### 0.2 设计原则

| 原则 | 说明 |
|:-----|:-----|
| **简单高效** | 数据包结构紧凑，适合低带宽场景 |
| **可靠性** | 双重校验（包级 CRC + 整包 SHA-256） |
| **安全性** | 支持 ECDSA 签名验证 + AES 加密传输 |
| **可扩展** | 预留扩展字段 |

---

## 1. 固件包格式

### 1.1 整体结构

```
+------------------+─────────────────────────────────+
|   Header         |  固定 256 Bytes                 |
+------------------+---------------------------------+
|   Payload        |  固件原始数据 (可变长度)        |
|   (可加密)       |                                 |
+------------------+---------------------------------+
```

### 1.2 Header 结构 (256 Bytes)

```c
#pragma pack(push, 1)

typedef struct {
    // ========== 1. 魔术字与版本 (7 Bytes) ==========
    uint8_t  magic[4];              // 0xAA, 0x55, 0xAA, 0x55
    uint8_t  version_major;         // 固件主版本号
    uint8_t  version_minor;         // 固件次版本号
    uint8_t  version_patch;         // 固件补丁版本号

    // ========== 2. 固件信息 (8 Bytes) ==========
    uint32_t firmware_size;         // Payload 实际大小 (Bytes)
    uint32_t firmware_crc;          // CRC-32 校验 (可选，0=不使用)

    // ========== 3. 安全信息 (96 Bytes) ==========
    uint8_t  sha256_hash[32];       // 固件 SHA-256 摘要
    uint8_t  signature_r[32];       // ECDSA 签名 r 分量
    uint8_t  signature_s[32];       // ECDSA 签名 s 分量

    // ========== 4. 标志位 (4 Bytes) ==========
    uint16_t flags;                 // 详见 1.3 节
    uint16_t header_crc;            // Header 自身的 CRC-16

    // ========== 5. 保留字段 (141 Bytes) ==========
    uint8_t  reserved[141];         // 填充至 256 Bytes

} OTA_PackageHeader_t;

#pragma pack(pop)
```

### 1.3 标志位定义

| Bit | 名称 | 说明 |
|:----|:-----|:-----|
| 0 | FLAG_ENCRYPTED | Payload 是否 AES-128 加密 |
| 1 | FLAG_ANTIROLLBACK | 是否启用防回滚检查 |
| 2 | FLAG_COMPRESSED | Payload 是否压缩 (预留) |
| 3-15 | RESERVED | 保留位 |

---

## 2. 通信数据包格式

### 2.1 数据包结构

所有数据包采用统一的头部格式：

```c
#pragma pack(push, 1)

typedef struct {
    // ========== 帧头 (4 Bytes) ==========
    uint8_t  sof;                   // 起始标志 0xA5
    uint16_t length;                // 数据长度 (不含帧头和帧尾)
    uint8_t  seq;                   // 序列号 (0-255，循环使用)

    // ========== 命令/响应 (2 Bytes) ==========
    uint8_t  cmd;                   // 命令码 (详见 2.2 节)
    uint8_t  status;                // 状态码 (响应包使用)

    // ========== 数据载荷 (可变长度) ==========
    uint8_t  data[SMOTA_PACKET_MAX_SIZE];  // 最大 1024 Bytes

    // ========== 校验与帧尾 (3 Bytes) ==========
    uint16_t crc;                   // CRC-16 (CCITT)
    uint8_t  eof;                   // 结束标志 0x5A

} OTA_Packet_t;

#pragma pack(pop)
```

### 2.2 命令码定义

| 命令码 | 名称 | 方向 | 说明 |
|:------|:-----|:-----|:-----|
| 0x01 | CMD_HANDSHAKE | Server → Device | 握手请求 |
| 0x02 | CMD_HEADER_INFO | Server → Device | 发送固件头部信息 |
| 0x03 | CMD_DATA_PACKET | Server → Device | 发送数据包 |
| 0x04 | CMD_DATA_REQUEST | Device → Server | 请求重传数据包 |
| 0x05 | CMD_EOF | Server → Device | 数据传输结束 |
| 0x06 | CMD_VERIFY | Device → Server | 验证完成通知 |
| 0x07 | CMD_ACTIVATE | Server → Device | 激活新固件 |
| 0x08 | CMD_ABORT | Server → Device | 中断升级 |
| 0x10 | CMD_ACK | Device → Server | 确认 |
| 0x11 | CMD_NACK | Device → Server | 非确认 (含错误码) |
| 0x20 | CMD_QUERY | Server → Device | 查询设备状态 |
| 0x21 | CMD_QUERY_RESP | Device → Server | 设备状态响应 |

### 2.3 状态码定义

| 状态码 | 名称 | 说明 |
|:------|:-----|:-----|
| 0x00 | STATUS_OK | 成功 |
| 0x01 | STATUS_BUSY | 设备忙 |
| 0x02 | STATUS_INVALID_PARAM | 参数错误 |
| 0x03 | STATUS_NO_MEMORY | 内存不足 |
| 0x04 | STATUS_TIMEOUT | 超时 |
| 0x10 | STATUS_CRC_ERROR | CRC 校验失败 |
| 0x11 | STATUS_HASH_MISMATCH | Hash 不匹配 |
| 0x12 | STATUS_SIGNATURE_INVALID | 签名无效 |
| 0x13 | STATUS_VERSION_ROLLBACK | 版本回滚 |
| 0x20 | STATUS_FLASH_ERROR | Flash 操作失败 |
| 0x21 | STATUS_PACKET_TOO_LARGE | 数据包过大 |
| 0x22 | STATUS_SEQUENCE_ERROR | 序列号错误 |

---

## 3. 升级流程

### 3.1 完整升级时序图

```
    Server                          Device
       │                               │
       │────── CMD_HANDSHAKE ────────▶│
       │                              │
       │◀──── CMD_ACK ─────────────────│
       │                              │
       │────── CMD_HEADER_INFO ──────▶│
       │  (Header + 签名)              │
       │                              │
       │◀──── CMD_ACK ─────────────────│
       │   (或 CMD_NACK)               │
       │                              │
       │────── CMD_DATA_PACKET ──────▶│
       │  (seq=0, data, crc)           │
       │                              │
       │◀──── CMD_ACK ─────────────────│
       │                              │
       │────── CMD_DATA_PACKET ──────▶│
       │  (seq=1, data, crc)           │
       │                              │
       │◀──── CMD_NACK ────────────────│
       │  (请重传 seq=1)               │
       │                              │
       │────── CMD_DATA_PACKET ──────▶│
       │  (seq=1, data, crc) 重传      │
       │                              │
       │◀──── CMD_ACK ─────────────────│
       │                              │
       │            ...                │
       │                              │
       │────── CMD_EOF ──────────────▶│
       │                              │
       │◀──── CMD_VERIFY ─────────────│
       │  (验签结果)                   │
       │                              │
       │────── CMD_ACTIVATE ─────────▶│
       │                              │
       │         (系统重启)            │
       │                              │
```

### 3.2 握手阶段

**请求 (Server → Device)**

```c
typedef struct {
    uint8_t protocol_version;        // 协议版本 (当前: 0x01)
    uint8_t flags;                   // 保留
    uint16_t max_packet_size;        // 最大包长度
    uint16_t timeout_ms;             // 超时时间 (ms)
} Handshake_Req_t;
```

**响应 (Device → Server)**

```c
typedef struct {
    uint8_t protocol_version;        // 设备支持的协议版本
    uint8_t capabilities;            // 能力标志位
    uint16_t max_packet_size;        // 设备最大包长度
    uint32_t flash_free_size;        // 可用 Flash 空间
} Handshake_Resp_t;
```

### 3.3 数据传输阶段

**数据包 (Server → Device)**

```c
typedef struct {
    uint32_t offset;                 // 在固件中的偏移
    uint16_t length;                 // 数据长度
    uint8_t  data[SMOTA_PACKET_MAX_SIZE];
    uint16_t crc;                    // 本包 CRC-16
} Data_Packet_t;
```

**重传请求 (Device → Server)**

```c
typedef struct {
    uint32_t offset;                 // 需要重传的偏移
    uint16_t length;                 // 需要重传的长度
} Data_Request_t;
```

---

## 4. 安全机制

### 4.1 签名验证

**算法**: ECDSA-P256 (secp256r1)

**流程**:
1. 服务器使用私钥对固件 SHA-256 摘要签名
2. 签名结果 (r, s) 存入 Header
3. 设备使用内置公钥验证签名

### 4.2 加密传输

**算法**: AES-128-CTR

**密钥派生**: 基于 MCU UID 的一机一密方案

```
HMAC-SHA256(Master_Key, MCU_UID || "smOTA_Enc_v1") → Device_Key
```

### 4.3 内容校验

| 层级 | 校验方式 | 覆盖范围 |
|:-----|:---------|:---------|
| 包级 | CRC-16 | 单个数据包 |
| 整体 | SHA-256 | 完整固件 |

---

## 5. 超时与重传

### 5.1 超时定义

| 场景 | 超时时间 |
|:-----|:---------|
| 数据包接收 | 5 秒 |
| 签名验证 | 30 秒 |
| Flash 擦除 | 根据页数计算 |

### 5.2 重传策略

| 错误类型 | 处理方式 |
|:---------|:---------|
| CRC 错误 | 请求重传当前包 |
| 序列号错误 | 请求重传 |
| Flash 写入失败 | 中断升级 |
| 签名验证失败 | 拒绝升级 |

---

## 6. 错误处理

### 6.1 错误码列表

```c
typedef enum {
    OTA_OK = 0,

    // 通用错误 (1-99)
    OTA_ERROR_UNKNOWN = -1,
    OTA_ERROR_NOT_INITIALIZED = -2,
    OTA_ERROR_INVALID_PARAM = -3,
    OTA_ERROR_NO_MEMORY = -4,
    OTA_ERROR_TIMEOUT = -5,

    // Flash 错误 (100-199)
    OTA_ERROR_FLASH_WRITE = -100,
    OTA_ERROR_FLASH_ERASE = -101,
    OTA_ERROR_FLASH_READ = -102,

    // 校验错误 (200-299)
    OTA_ERROR_CRC = -200,
    OTA_ERROR_HASH_MISMATCH = -201,
    OTA_ERROR_SIGNATURE_INVALID = -202,
    OTA_ERROR_VERSION_ROLLBACK = -203,

    // 协议错误 (300-399)
    OTA_ERROR_PACKET_INVALID = -300,
    OTA_ERROR_PACKET_TOO_LARGE = -301,
    OTA_ERROR_SEQUENCE_ERROR = -302,

    // 硬件错误 (400-499)
    OTA_ERROR_HAL_NOT_SUPPORTED = -400,
    OTA_ERROR_HAL_OPERATION_FAILED = -401,

} OTA_Error_t;
```

---

## 7. 附录

### 7.1 CRC-16 算法

多项式: `0x1021` (CCITT)
初始值: `0xFFFF`
反输入/输出: 否

### 7.2 示例数据包

```
完整数据包示例 (十六进制):

A5                    // SOF
1F 04                 // Length = 1059 Bytes
00                    // Seq = 0
02                    // CMD = CMD_HEADER_INFO
00                    // Status = 0

// Data: Header (256 Bytes)
AA 55 AA 55           // Magic
01 00 00              // Version 1.0.0
00 10 00 00           // Size = 4096 Bytes
...                   // 其他 Header 字段

// CRC & EOF
3A 7C                 // CRC-16
5A                    // EOF
```

---

**文档结束**
