# smOTA 待优化方案

> **文档版本**：v1.0
> **编写日期**：2026-01-27
> **状态**：设计探讨中（暂不实现）

---

## 目录

1. [前言](#1-前言)
2. [差分升级](#2-差分升级)
3. [压缩算法](#3-压缩算法)
4. [收益分析](#4-收益分析)
5. [适用场景](#5-适用场景)
6. [实现难点](#6-实现难点)

---

## 1. 前言

本文档记录 smOTA 未来可能优化的方向。这些功能目前**不在开发计划中**，待基础 OTA 稳定后再评估是否实现。

### 当前架构定位

smOTA 当前聚焦于**内部 Flash** 的全量升级方案：

| 升级模式 | Flash 布局 | 当前方案 |
|:---------|:-----------|:---------|
| 双 Bank 交换 | 硬件映射切换 | 全量写入备份 Bank |
| 双槽位搬运 | 软件分区搬运 | 全量写入备份槽位 |
| 单分区覆盖 | 单 App 分区 | 全量覆盖写入 |

### 为什么暂不实现

对于内部 Flash 方案：
- **差分升级**：收益有限 —— 有完整备份空间时，直接写入完整固件更简单可靠
- **压缩算法**：增加复杂度 —— 解压需要额外 RAM/CPU，对资源受限 MCU 不友好

---

## 2. 差分升级

### 2.1 原理

差分升级只传输新旧固件之间的差异部分，大幅减少传输数据量。

```
┌─────────────────────────────────────────────────────────────┐
│                     传统全量升级                             │
├─────────────────────────────────────────────────────────────┤
│  旧固件 (100KB)        新固件 (100KB)                        │
│       ┌──────────────────────────────────────┐              │
│       │ 传输 100KB 完整固件                   │              │
│       └──────────────────────────────────────┘              │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                     差分升级                                 │
├─────────────────────────────────────────────────────────────┤
│  旧固件 (100KB)        新固件 (100KB)                        │
│       ┌──────────────────────────────────────┐              │
│       │ 差异部分 ~10KB (仅 10%)               │              │
│       └──────────────────────────────────────┘              │
│                                                             │
│  设备端：新固件 = 旧固件 + 差分包 + 合成算法                 │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 常见算法

| 算法 | 压缩率 | 合成速度 | 库大小 | 适用场景 |
|:-----|:-------|:---------|:-------|:---------|
| **bsdiff** | 50-90% | 慢 | ~30KB | 固件变化小、带宽受限 |
| **HDiffPatch** | 50-85% | 快 | ~15KB | 平衡场景 |
| ** Courgette** | 30-70% | 快 | ~20KB | 指令级优化（ARM/x86） |

### 2.3 收益与支出

| 项目 | 说明 |
|:-----|:-----|
| **收益** | 传输数据量减少 50-90%，升级速度快，节省流量费用 |
| **支出** | 需要 Flash 存储旧固件、需要 4-32KB 工作 RAM、代码增加 10-30KB |
| **CPU 开销** | 差分合成过程较耗 CPU（尤其是 bsdiff） |

---

## 3. 压缩算法

### 3.1 原理

对固件进行压缩，减少传输数据量。

```
┌─────────────────────────────────────────────────────────────┐
│                     压缩升级流程                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  服务器端:  原始固件 ──压缩──▶ 压缩包 ──传输──▶ 设备端       │
│                                  │                         │
│                                  ▼                         │
│                            设备接收压缩包                    │
│                                  │                         │
│                                  ▼                         │
│                            解压缩（需要 RAM）                │
│                                  │                         │
│                                  ▼                         │
│                            写入 Flash                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 常见算法对比

| 算法 | 压缩率 | 解压 RAM | 代码大小 | CPU |
|:-----|:-------|:---------|:---------|:-----|
| **LZ4** | 40-50% | ~2KB | ~3KB | 极低 |
| **MiniLZ** | 50-60% | ~4KB | ~5KB | 低 |
| **Heatshrink** | 45-55% | ~1KB | ~4KB | 中 |
| **Deflate** | 50-65% | ~32KB | ~15KB | 高 |

### 3.3 收益与支出

| 项目 | 说明 |
|:-----|:-----|
| **收益** | 固件包减少 30-60%，节省传输时间 |
| **支出** | 解压需要 RAM（1-32KB）、解压需要 CPU 时间、代码增加 2-15KB |

---

## 4. 收益分析

### 4.1 不同 Flash 容量下的收益

| Flash 容量 | 全量升级 | 差分+压缩 | 推荐方案 |
|:-----------|:---------|:----------|:---------|
| **< 128KB** | ✓ | ✗ RAM 不足 | 全量 |
| **128-256KB** | ✓ | ⚠ 仅轻量压缩 | 全量 + 可选 LZ4 |
| **256-512KB** | ✓ | ⚠ 收益有限 | 全量优先 |
| **≥ 512KB** | ✓ | ✓ 有明显收益 | 全量 + 可选压缩 |
| **外部 Flash** | ✓ | ✓ ✓ 高收益 | 全量 + 差分 + 压缩 |

### 4.2 不同通信场景的收益

| 通信方式 | 带宽 | 成本 | 差分/压缩收益 |
|:---------|:-----|:-----|:-------------|
| **UART/USB** | 高 | 无 | 低（传输够快） |
| **WiFi/Ethernet** | 高 | 低 | 低 |
| **BLE** | 中 | 低 | 中 |
| **NB-IoT/LTE-M** | 低 | 高 | **高** |
| **LoRa** | 极低 | 高 | **极高** |

---

## 5. 适用场景

### 5.1 差分升级适用场景

```
✅ 推荐（有明显收益）
├── 外部 Flash + 内部运行（有空间存储旧固件）
├── NB-IoT / LTE-M 等低带宽、高费用网络
└── 固件较大（> 200KB）且版本间变化小

❌ 不推荐（收益有限或实现困难）
├── 单 APP 分区（无空间存储旧固件做差分）
├── 双 APP 分区（有完整备份空间，全量更简单）
└── RAM < 16KB 的芯片
```

### 5.2 压缩算法适用场景

```
✅ 推荐（有明显收益）
├── 固件较大（> 100KB）
├── 网络带宽受限（NB-IoT / LoRa）
└── RAM ≥ 8KB（可使用 Heatshrink/LZ4）

❌ 不推荐
├── RAM < 4KB 的芯片
├── 固件较小（< 50KB）
└── 对启动时间敏感的场景
```

---

## 6. 实现难点

### 6.1 差分升级难点

| 难点 | 说明 |
|:-----|:-----|
| **Flash 占用** | 需要额外空间存储旧固件用于差分合成 |
| **RAM 需求** | bsdiff 等算法需要 4-32KB 工作缓冲区 |
| **版本管理** | 需要记录当前固件版本，服务器端需要维护所有历史版本 |
| **合成时间** | 大固件的差分合成可能耗时较长 |

### 6.2 压缩算法难点

| 难点 | 说明 |
|:-----|:-----|
| **RAM 需求** | Deflate 等高压缩率算法需要 32KB+ RAM |
| **代码体积** | 压缩库占用宝贵的 Flash 空间 |
| **解压时间** | 增加升级过程的耗时 |
| **与加密结合** | 需要设计"先解压再加密"或"先加密再压缩"的流程 |

### 6.3 与现有架构的兼容性

```
┌─────────────────────────────────────────────────────────────┐
│                    现有架构限制                              │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  单分区模式:  ┌─────────────────────┐                      │
│              │  无备份区            │  ← 无法存储旧固件    │
│              │  差分无法实现         │                      │
│              └─────────────────────┘                      │
│                                                             │
│  双分区模式:  ┌──────────┐  ┌──────────┐                  │
│              │ Slot A   │  │ Slot B   │  ← 有完整备份    │
│              │ (运行)   │  │ (备份)   │     差分收益有限  │
│              └──────────┘  └──────────┘                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 7. 结论

### 当前建议

对于 smOTA 的**通用 MCU** 定位：

1. **优先完成全量升级** - 稳定可靠是第一优先级
2. **压缩作为可选项** - 使用轻量级算法（LZ4/Heatshrink），通过配置宏启用
3. **差分暂不实现** - 等有明确需求（外部 Flash 场景）再考虑

### 未来评估标准

当满足以下条件时，可重新评估差分/压缩的实现：

- [ ] 基础全量 OTA 已稳定运行
- [ ] 有外部 Flash 的产品需求
- [ ] 有 NB-IoT / LoRa 等低带宽场景需求
- [ ] 用户明确提出差分/压缩需求

---

## 附录 A：参考实现

| 项目 | 链接 | 说明 |
|:-----|:-----|:-----|
| **bsdiff** | https://github.com/mendsley/bsdiff | 经典差分算法 |
| **HDiffPatch** | https://github.com/sisong/HDiffPatch | 高性能差分补丁 |
| **LZ4** | https://github.com/lz4/lz4 | 极速压缩 |
| **Heatshrink** | https://github.com/atomicobject/heatshrink | 嵌入式友好压缩 |
| **Courgette** | https://chromium.googlesource.com/chromiumos/third_party/courgette | Chrome 使用的差分算法 |

---

**文档结束**
