# smOTA 密钥管理说明

> **文档版本**：v1.0
> **编写日期**：2026-01-26

---

## 目录

1. [密钥类型与用途](#1-密钥类型与用途)
2. [密钥提供方式](#2-密钥提供方式)
3. [密钥存储安全建议](#3-密钥存储安全建议)
4. [密钥生成工具](#4-密钥生成工具)
5. [配置示例](#5-配置示例)

---

## 1. 密钥类型与用途

smOTA 使用两种类型的密钥，分别用于不同的安全功能：

### 1.1 AES-128 主密钥 (Master Key)

| 属性 | 说明 |
|:-----|:-----|
| **用途** | 过程可靠性（Transmission Reliability） |
| **功能** | 固件包加密传输、HMAC 密钥派生 |
| **长度** | 16 字节 (128 位) |
| **算法** | AES-128-CTR |
| **启用条件** | `SMOTA_RELIABILITY_TRANSMISSION = 1` |

### 1.2 ECDSA-P256 公钥 (Public Key)

| 属性 | 说明 |
|:-----|:-----|
| **用途** | 来源可靠性（Source Reliability） |
| **功能** | 验证固件包签名 |
| **长度** | 64 字节 (256 位 × 2) |
| **算法** | ECDSA over secp256r1 (P-256) |
| **格式** | 未压缩格式，X 坐标(32B) + Y 坐标(32B) |
| **启用条件** | `SMOTA_RELIABILITY_SOURCE = 1` |

**注意**：私钥仅用于签名工具（PC 端），**绝不应**出现在 MCU 固件中。

### 1.3 ECDSA 签名与公钥的区别

在 smOTA 文档中，你会看到两组不同的 64 字节数据，它们用途完全不同：

#### 对比表

| | 公钥 (x, y) | 签名 (r, s) |
|:---|:---|:---|
| **是什么** | 椭圆曲线上的一个点 | 数字签名的两个分量 |
| **存储位置** | 设备内部 (`ecdsa_public_key.c`) | 固件包 Header (`signature_r`, `signature_s`) |
| **作用** | 验证签名 | 证明固件未被篡改 |
| **生成方式** | 由私钥派生（只需一次） | 每次打包固件时用私钥对固件哈希签名 |
| **格式** | 未压缩格式 64 字节 (x+y) | 64 字节 (r+s) |
| **文档位置** | 本文档 (密钥管理) | [4. OTA 协议规范](4.ota-protocol.md) |

#### 详细说明

**公钥 (x, y 坐标)**

```
公钥点 P = (x, y)
```

- 存储在 `examples/win_sim/keys/ecdsa_public_key.c` 中
- x 坐标：椭圆曲线上点的 x 坐标（32 字节）
- y 坐标：椭圆曲线上点的 y 坐标（32 字节）
- 每个设备/项目使用同一对密钥，编译后固化在固件中

**签名 (r, s 分量)**

```
签名(r, s) = ECDSA_Sign(私钥, 固件SHA256摘要)
```

- 存储在固件包 Header 的 `signature_r` 和 `signature_s` 字段中（见 [doc/4.ota-protocol.md](4.ota-protocol.md#12-header-结构-256-bytes)）
- r 分量：签名的第一个分量（32 字节）
- s 分量：签名的第二个分量（32 字节）
- 每次打包固件时都会生成新的签名

#### 验证流程

```
设备端验证流程:
┌─────────────────────────────────────────────────────────┐
│ 1. 计算固件 SHA256 摘要                                  │
│    hash = SHA256(firmware_payload)                       │
├─────────────────────────────────────────────────────────┤
│ 2. 从固件包 Header 提取签名 (r, s)                       │
│    signature = header.signature_r || header.signature_s  │
├─────────────────────────────────────────────────────────┤
│ 3. 使用内置公钥 (x, y) 验证签名                          │
│    valid = ECDSA_Verify(pub_key(x,y), hash, signature)   │
├─────────────────────────────────────────────────────────┤
│ 4. 验证通过 → 固件可信，继续升级                         │
│    验证失败 → 拒绝升级，报告错误                         │
└─────────────────────────────────────────────────────────┘
```

#### 代码示例

```c
// 固件包 Header 中的签名 (doc/4)
typedef struct {
    uint8_t sha256_hash[32];      // 固件 SHA-256 摘要
    uint8_t signature_r[32];      // ECDSA 签名 r 分量
    uint8_t signature_s[32];      // ECDSA 签名 s 分量
    // ...
} OTA_PackageHeader_t;

// 设备中存储的公钥 (doc/3)
static const uint8_t smota_ecdsa_pub_key_x[32] = { /* x 坐标 */ };
static const uint8_t smota_ecdsa_pub_key_y[32] = { /* y 坐标 */ };

// 验签时使用公钥 (x, y) 验证 Header 中的签名 (r, s)
int verify_signature(OTA_PackageHeader_t *header) {
    uint8_t hash[32];
    uint8_t signature[64];

    // 1. 计算固件哈希
    sha256(firmware_payload, firmware_size, hash);

    // 2. 组合签名 r + s
    memcpy(signature, header->signature_r, 32);
    memcpy(signature + 32, header->signature_s, 32);

    // 3. 用公钥 (x, y) 验证签名 (r, s)
    return ecdsa_verify(
        smota_ecdsa_pub_key_x,  // 公钥 x
        smota_ecdsa_pub_key_y,  // 公钥 y
        hash,                    // 固件哈希
        signature                // 签名 r+s
    );
}
```

---

## 2. 密钥提供方式

smOTA 要求用户实现密钥获取函数，支持密钥混淆、安全芯片等灵活场景。

### 自定义获取函数

用户需要实现 `smota_get_key()` 函数，根据密钥 ID 返回对应的密钥数据。

#### 函数原型

```c
/**
 * @brief 获取密钥数据（用户实现）
 * @param key_id  密钥 ID
 * @param out_key 输出缓冲区
 * @param len     缓冲区长度
 * @note  用户需在项目中实现此函数
 */
void smota_get_key(uint8_t key_id, uint8_t *out_key, uint32_t len);
```

#### 密钥 ID 定义

| ID | 宏定义 | 密钥类型 | 长度 | 用途 |
|:---|:-------|:---------|:-----|:-----|
| `0` | `SMOTA_KEY_AES_MASTER` | AES-128 主密钥 | 16 字节 | 加密传输 |
| `1` | `SMOTA_KEY_ECDSA_PUB` | ECDSA-P256 公钥 | 64 字节 | 签名验证 |

#### 实现示例

```c
#include <stdint.h>

// 密钥 ID 定义
#define SMOTA_KEY_AES_MASTER   0
#define SMOTA_KEY_ECDSA_PUB    1

// 示例 1：静态数组（简单但不够安全）
static const uint8_t g_aes_key[16] = {
    0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
    0xFE, 0xDC, 0xBA, 0x98, 0x76, 0x54, 0x32, 0x10
};

static const uint8_t g_ecdsa_pub_key[64] = {
    // X 坐标 (32 bytes)
    0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0,
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
    0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00,
    0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
    // Y 坐标 (32 bytes)
    0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11,
    0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
    0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF, 0x00, 0x11,
    0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99
};

void smota_get_key(uint8_t key_id, uint8_t *out_key, uint32_t len) {
    switch (key_id) {
        case SMOTA_KEY_AES_MASTER:
            if (len >= 16) {
                memcpy(out_key, g_aes_key, 16);
            }
            break;

        case SMOTA_KEY_ECDSA_PUB:
            if (len >= 64) {
                memcpy(out_key, g_ecdsa_pub_key, 64);
            }
            break;
    }
}
```

```c
// 示例 2：混淆存储（推荐）
static const uint8_t k1[16] = {0x55, 0xAA, ...};
static const uint8_t k2[16] = {0x12, 0x34, ...};

void smota_get_key(uint8_t key_id, uint8_t *out_key, uint32_t len) {
    switch (key_id) {
        case SMOTA_KEY_AES_MASTER:
            if (len >= 16) {
                for (int i = 0; i < 16; i++) {
                    out_key[i] = k1[i] ^ k2[i];  // 运行时异或还原
                }
            }
            break;
        // ...
    }
}
```

```c
// 示例 3：从安全芯片读取（最安全）
void smota_get_key(uint8_t key_id, uint8_t *out_key, uint32_t len) {
    switch (key_id) {
        case SMOTA_KEY_AES_MASTER:
            secure_chip_read_key(0, out_key, len);  // 从 SE05X 等安全芯片读取
            break;
        // ...
    }
}
```

---

## 3. 密钥存储安全建议

### 3.1 基本原则

| 原则 | 说明 |
|:-----|:-----|
| **分离存储** | 密钥文件单独存放，不与配置文件混合 |
| **版本控制隔离** | 密钥文件加入 `.gitignore`，不提交到仓库 |
| **读保护** | 启用 MCU 的 Flash 读保护（RDP） |
| **混淆** | 对密钥进行混淆处理，增加逆向难度 |

### 3.2 .gitignore 配置

```
# 密钥文件，不要提交到版本控制
smota_keys.c
smota_keys.h
*_key.c
*_key.h
```

### 3.3 MCU 读保护

| 平台 | 读保护功能 | 配置方式 |
|:-----|-----------|:---------|
| STM32 | RDP (Read Out Protection) | STM32CubeProgrammer / Option Bytes |
| GD32 | 安全芯片 | GD32 Programmer |
| ESP32 | Flash Encryption | efuse 配置 |

**重要**：任何密钥保护方案在未启用 MCU 读保护的情况下都是无效的！

### 3.4 密钥混淆示例

```c
// 不推荐：明文存储
const uint8_t key[16] = {0x01, 0x23, 0x45, ...};

// 推荐：混淆存储
static const uint8_t key_xor_mask[16] = {0x55, 0xAA, ...};
static const uint8_t key_obfuscated[16] = {
    0x54, 0x89, 0x30, ...  // 原密钥与 mask 异或的结果
};

void get_real_key(uint8_t *out) {
    for (int i = 0; i < 16; i++) {
        out[i] = key_obfuscated[i] ^ key_xor_mask[i];
    }
}
```

---

## 4. 密钥生成工具

smOTA 提供 Python 脚本 `scripts/keygen.py` 用于生成密钥。

### 4.1 安装依赖

```bash
pip install cryptography
```

### 4.2 使用方法

```bash
# 生成所有密钥（ECDSA 密钥对 + AES 密钥）
python scripts/keygen.py

# 仅生成 ECDSA 密钥对
python scripts/keygen.py --ecdsa

# 仅生成 AES 密钥
python scripts/keygen.py --aes

# 指定输出目录
python scripts/keygen.py --output my_keys/

# 生成 smota_keys.c 文件（可直接使用）
python scripts/keygen.py --c-file
```

### 4.3 输出文件

| 文件 | 说明 |
|:-----|:-----|
| `ecdsa_private_key.pem` | ECDSA 私钥（用于签名，**妥善保管**） |
| `ecdsa_public_key.bin` | ECDSA 公钥（64 字节二进制） |
| `ecdsa_public_key.c` | ECDSA 公钥（C 数组格式） |
| `aes_master_key.bin` | AES 主密钥（16 字节二进制） |
| `aes_master_key.c` | AES 主密钥（C 数组格式） |
| `smota_keys.c` | 完整的密钥实现文件（含 `smota_get_key()` 函数） |

### 4.4 快速开始

最简单的方式是直接生成 `smota_keys.c`：

```bash
# 生成包含所有密钥的 smota_keys.c
python scripts/keygen.py --c-file

# 将生成的文件复制到项目中
cp keys/smota_keys.c your_project/src/
```

然后在项目中只需调用 `smota_get_key()` 即可获取密钥。

---

## 5. 配置示例

### 5.1 最小配置（无加密）

```c
// smota_user_config.h
#define SMOTA_RELIABILITY_SOURCE 0
#define SMOTA_RELIABILITY_TRANSMISSION 0
// 无需实现 smota_get_key()
```

### 5.2 仅签名验证

```c
// smota_user_config.h
#define SMOTA_RELIABILITY_SOURCE 1
#define SMOTA_RELIABILITY_TRANSMISSION 0

// smota_keys.c
#include <stdint.h>
#include <string.h>

#define SMOTA_KEY_ECDSA_PUB 1

static const uint8_t g_ecdsa_pub_key[64] = {
    // 公钥数据...
};

void smota_get_key(uint8_t key_id, uint8_t *out_key, uint32_t len) {
    if (key_id == SMOTA_KEY_ECDSA_PUB && len >= 64) {
        memcpy(out_key, g_ecdsa_pub_key, 64);
    }
}
```

### 5.3 仅加密传输

```c
// smota_user_config.h
#define SMOTA_RELIABILITY_SOURCE 0
#define SMOTA_RELIABILITY_TRANSMISSION 1

// smota_keys.c
#include <stdint.h>
#include <string.h>

#define SMOTA_KEY_AES_MASTER 0

static const uint8_t g_aes_key[16] = {
    // AES 密钥...
};

void smota_get_key(uint8_t key_id, uint8_t *out_key, uint32_t len) {
    if (key_id == SMOTA_KEY_AES_MASTER && len >= 16) {
        memcpy(out_key, g_aes_key, 16);
    }
}
```

### 5.4 完整安全配置

```c
// smota_user_config.h
#define SMOTA_RELIABILITY_SOURCE 1
#define SMOTA_RELIABILITY_TRANSMISSION 1
#define SMOTA_RELIABILITY_VERSION 1

// smota_keys.c
#include <stdint.h>
#include <string.h>

#define SMOTA_KEY_AES_MASTER 0
#define SMOTA_KEY_ECDSA_PUB  1

static const uint8_t g_aes_key[16] = { /* AES 密钥 */ };
static const uint8_t g_ecdsa_pub_key[64] = { /* ECDSA 公钥 */ };

void smota_get_key(uint8_t key_id, uint8_t *out_key, uint32_t len) {
    switch (key_id) {
        case SMOTA_KEY_AES_MASTER:
            if (len >= 16) memcpy(out_key, g_aes_key, 16);
            break;
        case SMOTA_KEY_ECDSA_PUB:
            if (len >= 64) memcpy(out_key, g_ecdsa_pub_key, 64);
            break;
    }
}
```

---

## 附录

### A. 密钥长度总结

| 密钥类型 | 长度（字节） | 长度（位） | 用途 |
|:---------|:-------------|:-----------|:-----|
| AES-128 主密钥 | 16 | 128 | 加密传输 |
| ECDSA-P256 私钥 | 32 | 256 | 签名（PC 端） |
| ECDSA-P256 公钥 | 64 | 256 | 验签（MCU 端） |
| SHA-256 哈希 | 32 | 256 | 完整性校验 |

### B. 相关配置宏

| 宏 | 默认值 | 说明 |
|:---|:-------|:-----|
| `SMOTA_RELIABILITY_SOURCE` | 0 | 是否启用签名验证 |
| `SMOTA_RELIABILITY_TRANSMISSION` | 0 | 是否启用加密传输 |
| `SMOTA_KDF_CONTEXT` | "smOTA_Enc_v1" | 密钥派生上下文 |

### C. 密钥 ID 定义

用户在实现 `smota_get_key()` 时需要使用以下密钥 ID：

| 宏定义 | 值 | 密钥类型 |
|:-------|:---|:---------|
| `SMOTA_KEY_AES_MASTER` | 0 | AES-128 主密钥 |
| `SMOTA_KEY_ECDSA_PUB` | 1 | ECDSA-P256 公钥 |

---

**文档结束**
